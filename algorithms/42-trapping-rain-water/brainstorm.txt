// wrong v1

# height = [0,1,0,2,1,0,1,3,2,1,2,1]
height=[4,2,3]

def water(input):
  left = 0
  right = len(height) - 1
  total_water = 0
  lbound_height = 0
  rbound_height = 0

  while left < right:
    lbound_height = height[left]
    rbound_height = height[right]
    while (left < right and lbound_height > height[left+1]):
      total_water += lbound_height - height[left+1]
      left +=1
    else:
      if (left < right):
        left +=1
    while (left < right and rbound_height > height[right-1]):
      total_water += rbound_height - height[right-1]
      right -=1
    else:
      if (left < right):
        right -=1

  return total_water

print(water(height))



// v2 removed

  # while left < right:
  #   if (height[left] > height[left+1]):
  #     total_water += height[left] - height[left+1]
  #     if (height[left] == height[left+1]):
  #       total_water +=
  #     left +=1
  #   elif (height[left] <= height[left+1]):
  #     left +=1
    
  #   if (height[right] > height[right-1]):
  #     total_water += height[right] - height[right-1]
  #     right -=1
  #   elif (height[right] <= height[right-1]):
  #     right -=1
  # return total_water

  // v3 wrong, adding multiple times when considering middle popped
  multiple considerations of the same heights

    while left < right:
    popped_height = height[left + 1: right]
    for n in popped_height:
      if (n < (height[left] and n < height[right])):
        bucket += min(height[left], height[right]) - n
        if (height[left] > height[right]):
          right -=1
        else:
          left +=1
  return bucket


   while left < right:
      

      if height[left + 1] > min(height[left], height[temp_right]):
        bucket += min(height[left], height[temp_right]) - height[left + 1]

      left += 1
  return bucket

print(water(height))


height=[4,2,3]

def water(height):
  left = 0
  right = len(height) - 1
  left_max = 0
  right_max = 0
  bucket = 0

  while left < right:
    left_max = max(height[left],left_max)
    right_max = max(height[right],right_max)
    min_bar = min(left_max, right_max)

    if height[left] <= height[right]:
      bucket += max(0, min_bar - height[left])
      left += 1
    elif height[left] > height[right]:
      bucket += max(0, min_bar - height[right])
      right -= 1
      

  return bucket
print(water(height))


// finally...

kept going around trying to use 3 pointers and not moving the 2 pointers correctly
by keeping track of the highest left and right bars seen you can check for possible water trappings

define left 0 and left max 0 
define right as the length of the given list and right max as 0 to start
define a variable to add up the water bucket in this case
while the left and right pointers haven't crossed..
define the leftmax and right max every loop
optionally define a minimum bar to avoid using min everytime you need to find the smallest of the two max bars
pointers are greedily moved based on whichever current water level is higher
  this is important as the lowest current water level is the bottleneck thus you move that pointer over to maybe find a taller wall and expand the trap
if equal choose one to move,doesn't matter which as long as the right water level is added fro mthe side you move the pointer
in this unordered list you cannot predict whether the height bar you're on is higher than the current max which means you might get a negative number
in this case you avoid this by simply using max to compare 0 and the result
when you attain a negative number it means that the current bar is a very high wall and therefore wouldn't be a hole in the first place
so without max 0 in place you would run the risk of adding a negative number into the bucket thus getting the water kevek wrong 
